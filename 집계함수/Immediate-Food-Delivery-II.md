# **Immediate-Food-Delivery-II**

- [https://leetcode.com/problems/immediate-food-delivery-ii/](https://leetcode.com/problems/immediate-food-delivery-ii/)
- **문제 :** 고객 ID별로 가장 첫번 째 주문한 주문에 대해서 고객 선호 배송 날짜가 주문 날짜와 같은 주문의 비율을 구하는 문제 입니다. 즉, 고객별로 첫 주문 중 ‘즉시’ 주문의 비율을 찾는 문제 입니다. 여러개의 테스트 케이스를 INSERT 구문으로 만들었습니다. 정답 출력은 소수점 3자리에서 반올림하여 2자리만 출력합니다.

```jsx
[ 문제 조건 ]
CREATE TABLE Delivery (
    delivery_id INT,
    customer_id INT,
    order_date DATE,
    customer_pref_delivery_date DATE
);
INSERT INTO Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) VALUES
(1,1,'2019-08-01','2019-08-02'), (2,2,'2019-08-02','2019-08-02'), (3,1,'2019-08-11','2019-08-12'),
(4,3,'2019-08-24','2019-08-24'), (5,3,'2019-08-21','2019-08-22'), (6,2,'2019-08-11','2019-08-13'),
(7,4,'2019-08-09','2019-08-09');
INSERT INTO Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) VALUES
(1, 1, '2019-08-01', '2019-08-02'),(2, 2, '2019-08-02', '2019-08-02'),(3, 1, '2019-08-11', '2019-08-12'),
(4, 3, '2019-08-24', '2019-08-24'),(5, 3, '2019-08-21', '2019-08-22'),(6, 2, '2019-08-11', '2019-08-13'),
(7, 4, '2019-08-09', '2019-08-09'),(8, 4, '2019-08-09', '2019-08-11');
INSERT INTO Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) VALUES
(289, 7, '2019-07-22', '2019-08-13'),(85, 90, '2019-08-01', '2019-08-18'),(982, 82, '2019-08-15', '2019-08-16'),
(325, 61, '2019-08-30', '2019-08-30'),(652, 18, '2019-08-05', '2019-08-15'),(176, 64, '2019-07-02', '2019-07-02'),
(248, 86, '2019-07-19', '2019-08-04'),(720, 7, '2019-07-08', '2019-08-20'),(557, 41, '2019-07-25', '2019-07-25'),
(426, 47, '2019-07-15', '2019-08-03'),(1000, 20, '2019-07-17', '2019-07-17'),(947, 71, '2019-07-14', '2019-08-18'),
(379, 27, '2019-07-09', '2019-08-14'),(886, 42, '2019-08-10', '2019-08-18'),(943, 94, '2019-08-06', '2019-08-08'),
(87, 85, '2019-07-19', '2019-07-29'),(179, 98, '2019-07-31', '2019-07-31'),(733, 53, '2019-08-22', '2019-08-24'),
(224, 81, '2019-08-31', '2019-08-31'),(394, 78, '2019-07-29', '2019-07-29'),(451, 47, '2019-07-01', '2019-08-24'),
(149, 1, '2019-08-29', '2019-08-29'),(328, 41, '2019-07-10', '2019-07-10'),(169, 100, '2019-08-31', '2019-08-31'),
(977, 92, '2019-08-17', '2019-08-31'),(492, 63, '2019-08-23', '2019-08-23'),(686, 88, '2019-08-25', '2019-08-26'),
(800, 47, '2019-07-16', '2019-07-16'),(638, 91, '2019-08-19', '2019-08-24'),(405, 74, '2019-08-29', '2019-08-30'),
(861, 10, '2019-08-08', '2019-08-24'),(984, 19, '2019-07-17', '2019-07-30'),(702, 5, '2019-07-21', '2019-08-20'),
(228, 100, '2019-07-27', '2019-08-24'),(461, 85, '2019-08-13', '2019-08-13'),(602, 81, '2019-08-29', '2019-08-29'),
(135, 98, '2019-08-23', '2019-08-23'),(489, 85, '2019-08-14', '2019-08-20'),(350, 3, '2019-08-05', '2019-08-05'),
(99, 42, '2019-07-02', '2019-08-06'),(449, 9, '2019-08-07', '2019-08-11'),(397, 83, '2019-08-12', '2019-08-21'),
(109, 71, '2019-08-29', '2019-08-30'),(526, 6, '2019-08-02', '2019-08-02'),(695, 71, '2019-07-24', '2019-07-25'),
(574, 68, '2019-08-15', '2019-08-18'),(268, 88, '2019-07-06', '2019-07-06'),(190, 46, '2019-07-18', '2019-08-19'),
(163, 27, '2019-07-28', '2019-07-28'),(476, 70, '2019-07-21', '2019-07-21'),(104, 72, '2019-08-30', '2019-08-30'),
(881, 58, '2019-07-18', '2019-07-18'),(47, 49, '2019-07-23', '2019-07-26'),(303, 82, '2019-08-08', '2019-08-09'),
(500, 74, '2019-08-27', '2019-08-28'),(65, 15, '2019-07-28', '2019-08-20'),(160, 82, '2019-07-01', '2019-08-28');
```

```jsx
[ 정답 ]
SELECT ROUND(COUNT(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE NULL END ) / COUNT(*) *100 , 2) AS immediate_percentage
FROM (
		SELECT	CUSTOMER_ID
		,		MIN(order_date)order_date
		,		MIN(customer_pref_delivery_date) customer_pref_delivery_date
		FROM DELIVERY
		GROUP BY CUSTOMER_ID
) TEMP
```

- **해설 :** 이 문제는 고객 별로 첫 주문의 주문일과 희망 배송일을 찾는게 중요한 문제입니다. 그 값을 구하기 위해 고객 ID 별로 그룹을 묶은 후 MIN 함수를 사용해 배송일과 희망 배송일을 구했습니다. 이렇게 MIN 함수를 사용하면, 한 고객이 같은날 주문을 많이 넣었어도 가장 빠른 배송 희망일을 찾아 올 수 있기 때문에 문제를 수월하게 풀 수 있습니다.
- 이렇게 얻은 서브쿼리 결과를 통해 COUNT 함수로 고객 희망일과 배송 희망일이 같은 것의 개수를 구하고, 전체 고객수를 구해 백분율을 구해주면 됩니다.
